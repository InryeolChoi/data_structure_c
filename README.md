# 자료구조
c언어로 구현. 필요한 부분은 직접 제작.
배열, 연결리스트, 스택, 큐, 트리, 그래프

# 배열
- 배열 초기화 및 생성 구현
- 배열, 동적/정적 할당, 메모리

# 연결리스트
연결리스트에는 3가지 종류가 존재한다.
기본, 이중, 원형 연결리스트가 그것이다.

## 기본 연결리스트- 생성, 소멸, 연산 구현 
- 탐색, 삽입, 삭제, 갯수세기 구현
- 테스트 구현

## 이중 연결리스트
- 생성, 소멸, 연산 구현
- 탐색, 삽입, 삭제, 갯수세기 구현
- 테스트 구현

## 원형 연결리스트
- 생성, 소멸, 연산 구현
- 탐색, 삽입, 삭제, 갯수세기 구현
- 테스트 구현


# 스택
- 가장 마지막에 들어간 데이터가 제일 먼저 나오고 (LIFO) <br> 가장 먼저 들어간 데이터는 가장 나중에 나옴. (FILO)
- 자동 메모리 (c언어에서 변수가 저장되는 곳) 역시 스택 구조로 이뤄져 있음.

## 배열로 스택 구현
* 전체 스택 = 구조체
    * 용량
    * 최상위 노드의 위치
    * 노드들 -> 이 부분이 배열
        * 동적할당으로 배열을 만든다.
        * 가리키는 것은 맨 아래의 노드
* 노드 한 개 = 구조체
    * 데이터

## 연결리스트로 스택 구현
* 전체 스택 = 구조체
    * 최상위 노드의 위치
    * 노드들 -> 이 부분이 연결리스트
    * 가리키는 것은 맨 아래의 노드
* 노드 한 개 = 구조체
    * 데이터
    * 다음 노드
 
# 큐
* 먼저 들어간 데이터가 먼저 나온다. 
* FIFO 구조.

## 배열로 만들기 : 원형 큐
### 문제점 1 : 처음/끝 구분
* front와 rear라는 개념을 사용.
* 모든 변수들을 하나하나 이동하지 않고, front와 rear만 옮김.
* front = 실제 전단의 위치
* rear = 실제 후단의 위치 + 1

### 문제점 2 : 제거연산의 한계
* 제거를 하면 할수록 큐의 가용 용량이 줄어들음. 
* 선형으로 하면 이 문제의 해결책을 찾을 수 없음.
* 그래서 원형 큐를 도입.

### 문제점 3 : 원형의 한계
* 원형 큐는 처음과 끝을 구분하기 어려움
* 그래서 큐의 공백과 포화를 구분해줘야 함.
* 실제 용량보다 1만큼 더 크게 만들어서 전단과 후단 
사이를 비게 함.
```
공백상태 :  .....  (공백) (전단 = 후단) ...
포화상태 :  (전단 = 공백) (후단) .....
```

### 원형 큐 : 연산
* 노드 생성, 노드 삭제, 큐 생성, 큐 삭제
* 사이즈측정, 포화측정, 공백측정

## 연결리스트로 만들기 : 리스트 큐
* 리스트를 이용해서 만든 큐

**장점**
* 좀 더 간단하다.
* 용량에 제한이 없다.

**단점**
* 성능이 낮다. 
* 노드를 생성/삭제 하기 위해 malloc(), free()를 호출해야 하므로.


# 트리


# 덱
-
-
-
-
